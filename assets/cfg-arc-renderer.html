<!DOCTYPE html>
<head>
<meta charset="utf-8">
<style>

html, body {
  height: 100%;
}
text {
  font: 12px monospace;
  pointer-events: none;
}
svg {
    background-color: white;
}
path {
  animation: dash 1.5s linear infinite;
  animation-play-state: paused;
}
.animated {
  animation-play-state: running;
}

@keyframes dash {
  to {
    stroke-dashoffset: -50; // lcm of sum of dasharray values to avoid flicker
  }
}
</style></head>
<html>
<body> <div id="graph"></div></body>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const vscode = acquireVsCodeApi()
var graph = undefined;
    nodes = undefined,
    links = undefined,
    y = undefined,
    nodeColor = undefined;

function addNeighbours(nodes, links) {
  nodes.forEach(n => {
    neigh = []
    links.forEach(l => {
      if(l.source == n.id) {
        neigh.push(l.target)
      }
      else if (l.target == n.id) {
        neigh.push(l.source)
      }
    })
    n.neigh = Array.from(new Set(neigh))
  })
  return nodes;
}

// set the dimensions and margins of the graph
var rect = document.getElementById('graph').getBoundingClientRect();
const margin = {top: 20, right: 30, bottom: 20, left: 30},
      width = rect.width;

function getShortenName(d) {
  var name = d.name.split(" IN ")[0]
  if(name.length > 14) {
    return name.slice(0, 12) + ".."
  }
  return name
}

function getDasharray(l) {
  if(l.type === "u")
    return "45,5"
  if(l.type === "c")
    return "18,7"
  return ""
}

function getNodeColor(color) {
  return function (d) {
    const name = d.name.split(" IN ");
    if(name.length > 1) {
      return color(name[1])
    }
    return color(d.name)
  }
}
const NODE_CENTER_X = 100
      NODE_RADIUS = 12,
      LINK_MAX_SPREAD = width - NODE_CENTER_X - NODE_RADIUS - margin.right - margin.left
      half_spread = LINK_MAX_SPREAD/2;
function map_to_max_spread(val, k) {
  c = LINK_MAX_SPREAD
  b = half_spread;
  return b + (c-b)*Math.atan(k*(val-b))*2/Math.PI
}

function getLinkPath(y) {
  return function (d) {
    start = y(d.source)
    end = y(d.target)
    if(d.type === 'f') {
      return `M ${NODE_CENTER_X} ${start+NODE_RADIUS} V ${end - NODE_RADIUS}`
    } else {
      half_distance = Math.abs((start-end)/2)
      map = map_to_max_spread(half_distance, .001)
      radius = half_distance > half_spread ? (half_distance**2 + map**2)/(2*map) : half_distance
      return `M ${NODE_CENTER_X+NODE_RADIUS} ${start}\
      A ${radius},${radius} 0 0,${start < end?1:0} ${NODE_CENTER_X+NODE_RADIUS},${end}`
    }
  }
}

var unfocusTimeout = undefined;
function focusNode(d) {
  if(unfocusTimeout) {
    clearTimeout(unfocusTimeout)
    unfocusTimeout = undefined;
  }
  nodes.style('fill', n =>
    !d.neigh.includes(n.id) && n.id != d.id
    ? "#BBB"
    : nodeColor(n))
    .style("stroke", n => n.id === d.id ? "black" : "none")

  links.filter(l => l.source !== d.id && l.target !== d.id)
    .style('stroke', '#5553')
    .style('stroke-width', '1')
    .classed('animated', false)
  links.filter(l => l.source === d.id || l.target === d.id)
    .style('stroke', l => (l.source === d.id) ? '#7bb' : '#b7b')
    .style('stroke-width', 4)
    .classed('animated', true)
}

function unfocus(delay) {
  unfocusTimeout = setTimeout(() => {
    unfocusTimeout = undefined;
    nodes.style('fill', nodeColor)
         .style("stroke", "none")
    links
      .style('stroke', 'black')
      .style('stroke-width', '1')
      .classed('animated', false)
  }, delay)
}

function buildSVG(data) {

  const height = data.nodes.length * 32;

  data.nodes = addNeighbours(data.nodes, data.links)

  // append the svg object to the body of the page
  const svg = d3.select("#graph")
              .append("svg")
              .attr("width", width)
              .attr("height", height + margin.top + margin.bottom)
              .append("g")
              .attr("transform",`translate(${margin.left},${margin.top})`);

  // List of node names
  const allNodes = data.nodes.map(d=>d.id).sort((a,b)=> a-b)

  const sectionNames = data.nodes.filter(d=> !d.name.includes(" IN "))
  const color = d3.scaleOrdinal(sectionNames, d3.schemeCategory10)

  // A linear scale to position the nodes on the X axis
  y = d3.scalePoint()
            .range([0, height])
            .domain(allNodes)

  nodeColor = getNodeColor(color);

  // And give them a label
  const labels = svg
    .selectAll("mylabels")
    .data(data.nodes)
    .join("g")

  labels.append("rect")
    .attr("x", -margin.left)
    .attr("y", d => y(d.id) - 6)
    .attr("width", NODE_CENTER_X - NODE_RADIUS - 10 + margin.left)
    .attr("height", "1em")
    .attr("fill", "#fff")
    // .text(getShortenName)

  labels.append("text").text(getShortenName)
    .attr("x", NODE_CENTER_X - NODE_RADIUS - 10)
    .attr("y", d=>y(d.id))
    .style("text-anchor", "end")
    .style("alignment-baseline", "middle")
  labels.append("title").text(n => n.name)

  // Add the links
  links = svg
    .selectAll('mylinks')
    .data(data.links)
    .join('path')
    .attr('d', getLinkPath(y))
    .style("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-dasharray", getDasharray)

  // Add the circle for the nodes
  nodes = svg
    .selectAll("mynodes")
    .data(data.nodes)
    .join("circle")
      .attr("cx", NODE_CENTER_X)
      .attr("cy", d=>y(d.id))
      .attr("r", NODE_RADIUS)
      .style("fill", nodeColor)
      .style('stroke-width', 4)

  // Add the highlighting functionality
  nodes
    .on('mouseover', (_, n) => focusNode(n))
    .on('mouseout', () => unfocus(300))

  nodes.on("click", (_, n) => {
    vscode.postMessage({
        type: 'click',
        node: n.id
    })
  })
}

window.addEventListener('message', event => {
    switch (event.data.type) {
      case "graph_content":
        d3.select('#graph svg').remove()
        graph = JSON.parse(event.data.graph)
        buildSVG(graph)
      break;
        case "focused_proc":
        const node = graph.nodes
          .find(n => { return n.name === event.data.procedure })
        window.scroll(0, y(node.id)-window.innerHeight/3)
        focusNode(node)
        unfocus(5000)
        break;
    }
  })

vscode.postMessage({type: 'ready', graph_type: 'd3'})

</script>
